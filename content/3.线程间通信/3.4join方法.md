---
title: "3.4join方法"
date: 2021-09-27T18:59:10+08:00
draft: true
---

## 问题
子线程需要进行大量运算，主线程早于子线程退出。那么主线程无法获取子线程执行后的信息。

『解决方法』主线程中调用子线程的 join，使得在子线程运行时，主线程进入 waiting 状态。join 之后主线程原地等待子线程销毁。

<details>
<summary>MyThread.java</summary>

```java
public class MyThread extends Thread{
    @Override
    public void run(){
        try{
            long time = (long) (Math.random() * 10000);
            System.out.println("time:" + time);
            Thread.sleep(time);
        }catch(Exception e){

        }
    }
}
```

</details>

<details>
<summary>Run.java</summary>

```java
public class Run {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start();

        try {
            t.join();//使得主线程被无限期阻塞，等待子线程销毁
        } catch (Exception e){

        }
        System.out.println("can");
        System.out.println("you");
    }
}

```

</details>

## join 之后，线程的 interrupt() 方法可以引发 InterruptedException
<details>
<summary>ThreadA.java</summary>

```java
public class ThreadA extends Thread{
    @Override
    public void run(){
        try {
            for(int i = 0; ; i++){
                String str = new String("fine");
                if (isInterrupted()){
                    throw new InterruptedException();
                }
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }

    }
}
```

</details>

<details>
<summary>ThreadB.java</summary>

```java
public class ThreadB extends Thread{
    ThreadA a;
    @Override
    public void run(){
        try{
            a = new ThreadA();
            a.start();
            a.join();
            System.out.println("线程B继续执行");
        }catch (InterruptedException e){
            System.out.println("线程B被中断");
            e.printStackTrace();
            a.interrupt();
        }
    }
}
```

</details>

<details>
<summary>Run.java</summary>

```java
public class Run {
    public static void main(String[] args) {
        ThreadB b = new ThreadB();
        b.start();
        b.interrupt();
    }
}
```

</details>

默认情况下，interrupt() 方法不会引起线程异常，像线程A。而像线程 B 有调用了它的 join()，再调用 interrupt() 方法就会引起线程的中断异常。

运行结果

![](/多线程/3.线程通信/线程中断.png)




## join(long) 与 sleep(long) 的区别
- join 内部使用 wait() 来实现，所以会释放锁，允许其他线程进入同步区域。
- sleep 不会释放锁。
- join 之后主线程原地等待子线程销毁。
- 主线程调用 wait 需要获取子线程 t 的对象锁，因为 t.join() 涉及到 wait() 和同步。


<details>
<summary>ThreadA.java</summary>

```java
public class ThreadA extends Thread{
    ThreadB b;
    public ThreadA(ThreadB b){
        this.b = b;
    }
    @Override
    public void run(){
        try {
           synchronized (b){
               b.start();
               b.join(6000);//释放了当前线程对 b 的锁
               while(true){
               }
           }
        }catch (Exception e){
            e.printStackTrace();
        }

    }
}
```
</details>

执行结果
>B 开始<br>
>B 服务<br>
>B 结束<br>