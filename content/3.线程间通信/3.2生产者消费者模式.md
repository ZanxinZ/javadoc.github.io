---
title: "3.2生产者消费者模式"
date: 2021-09-22T11:23:40+08:00
draft: true
---

问题：
>threadP 在 setValue 时，lock.wait 失去了锁, 线程还会继续存在吗？
『解答』还会继续存在, 但是处于 waiting 状态。没有能力去获取同步锁。

>锁是可以重入的，是否意味着在 while 循环的作用下，会多次调用 setValue，而有一部分的调用被阻塞了得不到响应？ 
『解答』不会多次调用 setValue。

>锁可以重入，在上一个 lock.wait 未响应的情况下，是否可以再进入同步块进行对应操作？
『解答』执行了 lock.wait 线程就被挂起，进入 waiting 状态。

<details>
<summary>一个生产者、一个消费者</summary>

基于 wait/notify 机制
P.java
```java
public class P {
    String lock;
    public P(String lock){
        this.lock = lock;
    }
    public void setValue(){
        try{
            synchronized(lock){
                if (!ValueObject.value.equals("")){
                    lock.wait();//lock will be release, but thread exist always(waiting), and the thread loss the ability to get lock.
                }
                String str = System.currentTimeMillis() + "_" + System.nanoTime();
                System.out.println("Set:" + str);
                //Produce and notify
                ValueObject.value = str;
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

C.java
```java
public class C 
    String lock;
    public C(String lock){
        this.lock = lock;
    }
    public void getValue(){
        try{
            synchronized(lock){
                if (ValueObject.value.equals("")){
                    lock.wait();
                }
                String str = ValueObject.value;
                System.out.println("Get:" + str);
                //Consume and notify
                ValueObject.value = "";
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

ThreadP.java
```java
public class ThreadP extends Thread{
    public P p;
    public ThreadP(P p){
        super();
        this.p = p;
    }
    @Override
    public void run(){
        while(true){
            p.setValue();
        }
    }
}
```

ThreadC.java
```java
public class ThreadC extends Thread{
    public C c;
    public ThreadC(C c){
        super();
        this.c = c;
    }

    @Override
    public void run(){
        while(true){
            c.getValue();
        }
    }
}
```

Run.java
```java
public class Run {
    public static void main(String[] args){
        String lock = "s";
        Thread producer = new ThreadP(new P(lock));
        Thread consumer = new ThreadC(new C(lock));

        consumer.start();
        producer.start();
    }
}
```

</details>
<details>
<summary>多生产者多消费者——出现假死</summary>

多个生产者若使用 notify 进行通知，则可能出现『生产者通知消费者、消费者通知生产者、生产者通知生产者、消费者通知消费者』的情况，若通知出错的情况持续累积，就会造成程序假死。

P.java
```java
public class P {
    String lock;
    public P(String lock){
        this.lock = lock;
    }
    public void setValue(){
        try{
            synchronized(lock){
                while (!ValueObject.value.equals("")){
                    lock.wait();
                }
                String str = System.currentTimeMillis() + "_" + System.nanoTime();
                System.out.println(Thread.currentThread().getName() + " Set:" + str);
                //Produce and notify
                ValueObject.value = str;
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

C.java
```java
public class C {
    String lock;
    public C(String lock){
        this.lock = lock;
    }
    public void getValue(){
        try{
            synchronized(lock){
                while (ValueObject.value.equals("")){
                    lock.wait();
                }
                String str = ValueObject.value;
                System.out.println(Thread.currentThread().getName() + " Get:" + str);
                //Consume and notify
                ValueObject.value = "";
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

ThreadP.java
```java
public class ThreadP extends Thread{
    public P p;
    public ThreadP(P p){
        super();
        this.p = p;
    }
    @Override
    public void run(){
        while(true){
            p.setValue();
        }
    }
}
```

ThreadC.java
```java
public class ThreadC extends Thread{
    public C c;
    public ThreadC(C c){
        super();
        this.c = c;
    }

    @Override
    public void run(){
        while(true){
            c.getValue();
        }
    }
}
```

run.java
```java
public class Run {
    public static void main(String[] args){
        String lock = "s";
        Thread[] producer = new ThreadP[2];
        Thread[] consumer = new ThreadC[2];

        for (int i = 0; i < 2; i++) {
            producer[i] = new ThreadP(new P(lock));
            producer[i].setName("生产者" + (i+1));
            consumer[i] = new ThreadC(new C(lock));
            consumer[i].setName("消费者" + (i+1));
            producer[i].start();
            consumer[i].start();
        }
    }
}
```

如何解决 notify 通知不到其他类？
>使用 notifyAll() 
</details>