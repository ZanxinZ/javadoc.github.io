---
title: "3.2生产者消费者模式"
date: 2021-09-22T11:23:40+08:00
draft: true
---

问题：
>threadP 在 setValue 时，lock.wait 失去了锁, 线程还会继续存在吗？
『解答』还会继续存在, 但是处于 waiting 状态。没有能力去获取同步锁。

>锁是可以重入的，是否意味着在 while 循环的作用下，会多次调用 setValue，而有一部分的调用被阻塞了得不到响应？ 
『解答』不会多次调用 setValue。

>锁可以重入，在上一个 lock.wait 未响应的情况下，是否可以再进入同步块进行对应操作？
『解答』执行了 lock.wait 线程就被挂起，进入 waiting 状态。

<details>
<summary>一个生产者、一个消费者</summary>

基于 wait/notify 机制
P.java
```java
public class P {
    String lock;
    public P(String lock){
        this.lock = lock;
    }
    public void setValue(){
        try{
            synchronized(lock){
                if (!ValueObject.value.equals("")){
                    lock.wait();//lock will be release, but thread exist always(waiting), and the thread loss the ability to get lock.
                }
                String str = System.currentTimeMillis() + "_" + System.nanoTime();
                System.out.println("Set:" + str);
                //Produce and notify
                ValueObject.value = str;
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

C.java
```java
public class C 
    String lock;
    public C(String lock){
        this.lock = lock;
    }
    public void getValue(){
        try{
            synchronized(lock){
                if (ValueObject.value.equals("")){
                    lock.wait();
                }
                String str = ValueObject.value;
                System.out.println("Get:" + str);
                //Consume and notify
                ValueObject.value = "";
                lock.notify();
            }
        }catch (Exception e){

        }

    }
}
```

ThreadP.java
```java
public class ThreadP extends Thread{
    public P p;
    public ThreadP(P p){
        super();
        this.p = p;
    }
    @Override
    public void run(){
        while(true){
            p.setValue();
        }
    }
}
```

ThreadC.java
```java
public class ThreadC extends Thread{
    public C c;
    public ThreadC(C c){
        super();
        this.c = c;
    }

    @Override
    public void run(){
        while(true){
            c.getValue();
        }
    }
}
```

Run.java
```java
public class Run {
    public static void main(String[] args){
        String lock = "s";
        Thread producer = new ThreadP(new P(lock));
        Thread consumer = new ThreadC(new C(lock));

        consumer.start();
        producer.start();
    }
}
```
</details>
