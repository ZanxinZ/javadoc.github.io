---
title: "等待与通知机制"
date: 2021-09-09T20:03:54+08:00
draft: true
---

## while 轮询存在缺陷
- A 线程执行每一步的时间较长。
    ```java
        public class ThreadA extends Thread{
            private MyList list;

            public ThreadA(MyList list){
                super();
                this.list = list;
            }
            @Override
            public void run(){
                super.run();
                try{
                    for (int i = 0; i < 10; i++) {
                        list.add();
                        System.out.println(Thread.currentThread().getName() + " Add " + i);
                        Thread.sleep(1000);
                    }
                }catch (InterruptedException e){
                    e.printStackTrace();
                }

            }
        }

    ```

- B线程执行轮询的时间较短

    ```java
        public class ThreadB extends Thread{
            private MyList list;
            public ThreadB(MyList list){
                super();
                this.list = list;
            }
            @Override
            public void run(){
                super.run();
                try{
                    while (true){
                        if(list.size() >= 5){
                            System.out.println("B Up to five.");
                            throw new InterruptedException();
                        }
                        Thread.sleep(20);
                    }
                }catch (InterruptedException e){
                    e.printStackTrace();
                }

            }
        }
    ```
![while轮询](/多线程/3.线程通信/while轮询.png)

线程 A 和 执行循环每轮会休息 1s，线程 B 每隔 20ms 对 size 进行访问。而线程 B 的轮询，若时间太长则无法准确捕捉 list.size的变化；若时间太短则耗费大量的 CPU 资源。

所以，使用 while 来轮询变量或者对象属性，会造成 CPU 资源的浪费；轮询间隔越短，越耗费资源。

我们使用一种称为 wait/notify 的机制来解决这个问题。


多线程共享变量，会有**同步**的问题，线程无法确保读取到的变量值是不是最新版本，而 wait/notify机制 恰好可以解决**同步**这个问题。 

