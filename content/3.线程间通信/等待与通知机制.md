---
title: "等待与通知机制"
date: 2021-09-09T20:03:54+08:00
draft: true
---

## while 轮询存在缺陷
- A 线程执行每一步的时间较长。
    ```java
        public class ThreadA extends Thread{
            private MyList list;

            public ThreadA(MyList list){
                super();
                this.list = list;
            }
            @Override
            public void run(){
                super.run();
                try{
                    for (int i = 0; i < 10; i++) {
                        list.add();
                        System.out.println(Thread.currentThread().getName() + " Add " + i);
                        Thread.sleep(1000);
                    }
                }catch (InterruptedException e){
                    e.printStackTrace();
                }

            }
        }

    ```

- B线程执行轮询的时间较短

    ```java
        public class ThreadB extends Thread{
            private MyList list;
            public ThreadB(MyList list){
                super();
                this.list = list;
            }
            @Override
            public void run(){
                super.run();
                try{
                    while (true){
                        if(list.size() >= 5){
                            System.out.println("B Up to five.");
                            throw new InterruptedException();
                        }
                        Thread.sleep(20);
                    }
                }catch (InterruptedException e){
                    e.printStackTrace();
                }

            }
        }
    ```
![while轮询](/多线程/3.线程通信/while轮询.png)

线程 A 和 执行循环每轮会休息 1s，线程 B 每隔 20ms 对 size 进行访问。而线程 B 的轮询，若时间太长则无法准确捕捉 list.size的变化；若时间太短则耗费大量的 CPU 资源。

所以，使用 while 来轮询变量或者对象属性，会造成 CPU 资源的浪费；轮询间隔越短，越耗费资源。

我们使用一种称为 wait/notify 的机制来解决这个问题。


多线程共享变量，会有**同步**的问题，线程无法确保读取到的变量值是不是最新版本，而 wait/notify机制 恰好可以解决**同步**这个问题。 

## wait/notify 机制

Java 的对象都有 wait() 方法和 notify() 方法，但需要**同步加锁**才能使用这个 wait/notify 机制。

- 两个线程共用一个对象监视器 lock。
  
  一个线程中，调用对象监视器的 wait()，该线程释放锁，并且进入等待状态。

  另外一个线程，在需要的时候 调用对象监视器的 notify() 方法，会释放锁，并且**随机唤醒**等待同一共享资源的一个线程，但notify 在释放锁时并不是立即执行。

  - ThreadA.java
    ```java
    public class ThreadA extends Thread{
        private Object lock;

        public ThreadA(Object lock){
            super();
            this.lock = lock;
        }
        @Override
        public void run(){
            super.run();
            synchronized (lock){
                System.out.println("start.");
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("end");
            }
        }
    }
    ```
  - ThreadB.java
      ```java
       public class ThreadB extends Thread{
        private Object lock;
        public ThreadB(Object lock){
            super();
            this.lock = lock;
        }
        @Override
        public void run(){
            super.run();
            synchronized (lock){
                for (int i = 0; i < 7; i++) {
                    System.out.println(i);
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    if (i == 4){
                        lock.notify();
                    }
                }

            }

        }
    }
      ```
    

  - Run.java

    ```java
    public class Run {
        public static void main(String[] args) {
            Object lock = new Object();
            ThreadA A = new ThreadA(lock);
            A.setName("A");
            A.start();
            ThreadB B = new ThreadB(lock);
            B.setName("B");
            B.start();

        }
    }
    ```

    ![等待与通知](/多线程/3.线程通信/wait_notify.png)
    
    可以看到，在 i = 4 时调用notify( )，并不会马上释放锁。  