[{"id":0,"href":"/4.Lock/4.1ReentrantLock/","title":"4.1ReentrantLock","parent":"4.Lock","content":"ReentrantLock 可重入锁\n 嗅探锁定 多路分支通知  1. 实现同步功能     实现互斥   MyService.java import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class MyService { private Lock lock = new ReentrantLock(); public void service(){ lock.lock(); System.out.println(Thread.currentThread().getName()); for (int i = 0; i \u0026lt; 20; i++) { System.out.print(i); } System.out.println(); lock.unlock(); } }   MyThread.java public class MyThread extends Thread{ MyService service; public MyThread(MyService service){ this.service = service; } @Override public void run(){ service.service(); } }   Run.java public class Run { public static void main(String[] args) { MyService s = new MyService(); for (int i = 0; i \u0026lt; 5; i++) { MyThread t = new MyThread(s); t.setName(\u0026#34;Thread\u0026#34; + i); t.start(); } } }  运行结果\n2. wait/notify 的实现、    synchronized 与 wait() 和 notity()/notifyAll()方法的结合可以实现『等待/通知』模式。\nReentrantLock 与 Condition 也可实现同样的功能。\n在一个 Lock 对象中可以创建多个 Condition 对象。线程对象可以注册在指定的 Condition 中，实现有选择性的线程通知。\n调用 condition.await() 之前需要先获取锁。\n线程被 await() 挂起之后，interrupt() 也会引起 InterruptedException.\nawait(long time, TimeUnit unit) 可以设定挂起时间。\nReentrantLock 与 condition    ReentrantLock 的 await 与 condition 的 signal\n MyService.java import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class MyService { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void await(){ try{ lock.lock();//需要先获取锁  System.out.println(\u0026#34;Ready\u0026#34;); condition.await(); System.out.println(Thread.currentThread().getName()); }catch (InterruptedException e){ e.printStackTrace(); }finally { lock.unlock(); } } public void signal(){ lock.lock(); condition.signal(); lock.unlock(); } }   MyThread.java public class MyThread extends Thread{ MyService service; public MyThread(MyService service){ this.service = service; } @Override public void run(){ service.await(); } }   Run.java public class Run { public static void main(String[] args) throws InterruptedException { MyService s = new MyService(); MyThread t = new MyThread(s); t.setName(\u0026#34;Ha\u0026#34;); t.start(); Thread.sleep(1000); s.signal(); } }  运行结果\n Ready\nHa\n 先显示 Ready，等待 1 秒之后挂起的线程被通知，打印 Ha。\n3. 生产者消费者模式    "},{"id":1,"href":"/4.lock/","title":"4.Lock","parent":"简介","content":""},{"id":2,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.5%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F%E7%A7%81%E6%9C%89/","title":"3.5线程变量私有","parent":"3.线程间通信","content":"如果需要线程间进行变量共享，可以把变量定义为 public static.\n如果需要线程内部的变量共享，可以使用 ThreadLocal.\n1. ThreadLocal    public static ThreadLocal t = new ThreadLocal();\nThreadLocal 具有 get() 和 set() 方法，不同线程拥有自己的域。\n 子线程MyThread.java public class MyThread extends Thread{ @Override public void run(){ if (Run.t.get()==null){ System.out.println(\u0026#34;无\u0026#34;); Run.t.set(\u0026#34;子线程数据\u0026#34;); } System.out.println(Run.t.get()); } }    主线程 Run.java public class Run { public static ThreadLocal t = new ThreadLocal(); public static void main(String[] args) { MyThread s = new MyThread(); s.start(); if (t.get() == null){ System.out.println(\u0026#34;未有值\u0026#34;); t.set(\u0026#34;Hi\u0026#34;); } System.out.println(t.get()); }   运行结果\n 未有值\nHi\n无\n子线程数据\n 这表明，不同线程去访问同一静态域 t，所得到的内容是不一样的。每个线程只能取得属于自己的那一份。\n若需要给 ThreadLocal 设置初始值    可以继承 ThreadLocal 并且重写值初始化方法。\npublic class MyThreadLocal extends ThreadLocal{ @Override protected Object initialValue(){ return \u0026#34;fine\u0026#34;; } } 2.InheritableThreadLocal    public static ThreadLocal t = new InheritableThreadLocal();\n线程值继承    当前线程的值，第一次访问(set 或者 get)之后才生效，才可被继承。\n  父线程的值被访问过之后，子线程可以继承父线程的值，但子线程值修改(set)对父线程没有影响。\n  若父线程的值未被访问，子线程访问所得到的值是默认值。\n 子线程访问到的是默认值 public class Run { public static ThreadLocal t = new MyInheritableThreadLocal(); public static void main(String[] args) throws InterruptedException { MyThread s = new MyThread(); s.start(); } } 运行结果\n fine\n   父线程的值有被访问，则子线程会继承 public class Run { public static ThreadLocal t = new MyInheritableThreadLocal(); public static void main(String[] args) throws InterruptedException { System.out.println(t.get());//父线程的值有被访问  MyThread s = new MyThread(); s.start(); } } 运行结果\n fine\nfineHa\n    父线程修改了值，并且执行了其他语句之后，子线程再来继承所得到的值就是新的值。\n  如果在子线程获取值的时候，父线程修改了值，那么子线程获取到的是旧的值。\n  若想要在继承的同时对子线程的值进行修改，可以重写 childValue 方法。\n MyInheritableThreadLocal.java public class MyInheritableThreadLocal extends InheritableThreadLocal{ @Override protected Object initialValue(){ return \u0026#34;fine\u0026#34;; } @Override protected Object childValue(Object parentValue){ return parentValue + \u0026#34;Ha\u0026#34;; } }    "},{"id":3,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.4join%E6%96%B9%E6%B3%95/","title":"3.4join方法","parent":"3.线程间通信","content":"问题    子线程需要进行大量运算，主线程早于子线程退出。那么主线程无法获取子线程执行后的信息。\n『解决方法』主线程中调用子线程的 join，使得在子线程运行时，主线程进入 waiting 状态。join 之后主线程原地等待子线程销毁。\n MyThread.java public class MyThread extends Thread{ @Override public void run(){ try{ long time = (long) (Math.random() * 10000); System.out.println(\u0026#34;time:\u0026#34; + time); Thread.sleep(time); }catch(Exception e){ } } }   Run.java public class Run { public static void main(String[] args) { Thread t = new MyThread(); t.start(); try { t.join();//使得主线程被无限期阻塞，等待子线程销毁  } catch (Exception e){ } System.out.println(\u0026#34;can\u0026#34;); System.out.println(\u0026#34;you\u0026#34;); } }  join 之后，线程的 interrupt() 方法可以引发 InterruptedException     ThreadA.java public class ThreadA extends Thread{ @Override public void run(){ try { for(int i = 0; ; i++){ String str = new String(\u0026#34;fine\u0026#34;); if (isInterrupted()){ throw new InterruptedException(); } } }catch (InterruptedException e){ e.printStackTrace(); } } }   ThreadB.java public class ThreadB extends Thread{ ThreadA a; @Override public void run(){ try{ a = new ThreadA(); a.start(); a.join(); System.out.println(\u0026#34;线程B继续执行\u0026#34;); }catch (InterruptedException e){ System.out.println(\u0026#34;线程B被中断\u0026#34;); e.printStackTrace(); a.interrupt(); } } }   Run.java public class Run { public static void main(String[] args) { ThreadB b = new ThreadB(); b.start(); b.interrupt(); } }  默认情况下，interrupt() 方法不会引起线程异常，像线程A。而像线程 B 有调用了它的 join()，再调用 interrupt() 方法就会引起线程的中断异常。\n运行结果\njoin(long) 与 sleep(long) 的区别     join 内部使用 wait() 来实现，所以会释放锁，允许其他线程进入同步区域。 sleep 不会释放锁。 join 之后主线程原地等待子线程销毁。 主线程调用 wait 需要获取子线程 t 的对象锁，因为 t.join() 涉及到 wait() 和同步。   ThreadA.java public class ThreadA extends Thread{ ThreadB b; public ThreadA(ThreadB b){ this.b = b; } @Override public void run(){ try { synchronized (b){ b.start(); b.join(6000);//释放了当前线程对 b 的锁  while(true){ } } }catch (Exception e){ e.printStackTrace(); } } }  执行结果\n B 开始\nB 服务\nB 结束\n join 后面的内容提前执行     ThreadA.java public class ThreadA extends Thread{ ThreadB b; public ThreadA(ThreadB b){ this.b = b; } @Override public void run(){ try { synchronized (b){ System.out.println(\u0026#34;A start\u0026#34;); Thread.sleep(5000);//不释放锁，主线程无法访问 b  //b.wait();//会释放锁  System.out.println(\u0026#34;A end\u0026#34;); } }catch (Exception e){ e.printStackTrace(); } } }   ThreadB.java public class ThreadB extends Thread{ @Override synchronized public void run(){ try{ System.out.println(\u0026#34;B start\u0026#34;); Thread.sleep(6000); System.out.println(\u0026#34;B end\u0026#34;); }catch (InterruptedException e){ e.printStackTrace(); } } }   Run.java public class Run { public static void main(String[] args) { ThreadB b = new ThreadB(); ThreadA a = new ThreadA(b); try{ a.start();//一旦线程 a 进入 run，会占有 b 锁并且不释放。  b.start(); b.join(4000);//这一行比前面两个 start 都要早执行，主线程阻塞等待 b 线程 4000ms。  System.out.println(\u0026#34;Main end\u0026#34;); }catch (InterruptedException e){ } } }  执行顺序\n运行结果有三种可能\n    b.join(4000) 先拿到锁并且很快释放。 a 拿到锁，开始执行，不释放锁。持续 5000ms。 b.join(4000) 比线程 b 先拿到锁，但很快又释放，但此时已经过了 4000ms ，于是主线程不再阻塞，继续执行打印 Main end。 b.start() 拿到锁就开始执行，不释放锁。持续 6000ms。   A start\nA end\nMain end\nB start\nB end\n 和第一种情况一样，只是 ThreadB 在争夺锁的时候比 Main end 的打印快了一点。   Main end 和『B 开始』异步打印，Main end 慢了一点。   A start\nA end\nB start\nMain end\nB end\n    b.join(4000) 先拿到锁并且很快释放。 a 拿到锁，开始执行，不释放锁。持续 5000ms。 线程 b 比 b.join(4000) 先拿到锁，不释放锁，持续 6000ms。然后输出『结束』 b.join(4000) 再次拿到锁。时间已经超过 4000ms, 主线程不再等待，打印 Main end。   A start\nA end\nB start\nB end\nMain end\n "},{"id":4,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.3%E7%AE%A1%E9%81%93%E6%B5%81/","title":"3.3管道流","parent":"3.线程间通信","content":"一个线程发送数据到输出管道，另外一个线程从输入管道中读取数据。\n工具类：PipedInputStream, PipedOutputStream, PipedReader, PipedWriter\nPipedInputStream 通信大小有限制，一个批次默认是 1024 字节。\n发送者写满 1024 字节后，接收者开始读取，读取完成一批之后再开始下一批。\n传输字节流     WriteData.java import java.io.PipedOutputStream; public class WriteData { public void write(PipedOutputStream outputStream){ try{ System.out.println(\u0026#34;Write:\u0026#34; + Thread.currentThread().getName()); for (int i = 0; i \u0026lt; 300; i++) { String s = \u0026#34;i=\u0026#34; + i; outputStream.write(s.getBytes()); System.out.println(s); } }catch (Exception e){ } } }   ReadData.java import java.io.PipedInputStream; public class ReadData { public void read(PipedInputStream inputStream){ try{ System.out.println(\u0026#34;Read:\u0026#34; + Thread.currentThread().getName()); byte [] data = new byte[40]; int b = inputStream.read(data); while(b != -1){ String str = new String(data, 0, b); System.out.println(str); b = inputStream.read(data); } }catch (Exception e){ } } }   ThreadWrite.java import java.io.PipedOutputStream; public class ThreadWrite extends Thread{ private WriteData writeData; private PipedOutputStream outputStream; public ThreadWrite(PipedOutputStream outputStream, WriteData writeData){ this.outputStream = outputStream; this.writeData = writeData; } @Override public void run(){ writeData.write(outputStream); } }   ThreadRead.java import java.io.PipedInputStream; public class ThreadRead extends Thread{ private PipedInputStream inputStream; private ReadData readData; public ThreadRead(PipedInputStream inputStream, ReadData readData){ this.inputStream = inputStream; this.readData = readData; } @Override public void run(){ readData.read(inputStream); } }   Run.java import java.io.PipedInputStream; import java.io.PipedOutputStream; public class Run { public static void main(String[] args) { WriteData writeData = new WriteData(); ReadData readData = new ReadData(); PipedInputStream inputStream = new PipedInputStream(); PipedOutputStream outputStream = new PipedOutputStream(); try { outputStream.connect(inputStream); // connect pipe  }catch (Exception e){ } ThreadWrite write = new ThreadWrite(outputStream, writeData); ThreadRead read = new ThreadRead(inputStream, readData); write.setName(\u0026#34;发送者\u0026#34;); read.setName(\u0026#34;接收者\u0026#34;); write.start(); read.start(); } }  刚刚开始的时候，缓存区没有内容，接收者线程阻塞在 int b = inputStream.read(data); 直到整批内容写完。写和读的线程之间通过 b 来同步。\n传输字符流    write 时\noutputStream.write(str);\nread 时\nchar[] data = new char[40];\nString str = new String(data, 0, length);\n"},{"id":5,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.2%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"3.2生产者消费者模式","parent":"3.线程间通信","content":"问题：\n threadP 在 setValue 时，lock.wait 失去了锁, 线程还会继续存在吗？ 『解答』还会继续存在, 但是处于 waiting 状态。没有能力去获取同步锁。\n  锁是可以重入的，是否意味着在 while 循环的作用下，会多次调用 setValue，而有一部分的调用被阻塞了得不到响应？ 『解答』不会多次调用 setValue, 因为执行了lock。wait() 之后线程被挂起了。\n  锁可以重入，在上一个 lock.wait 未响应的情况下，是否可以再进入同步块进行对应操作？ 『解答』执行了 lock.wait 线程就被挂起，进入 waiting 状态。\n 一个生产者、一个消费者    基于 wait/notify 机制\n若数据域有内容，则生产者不生产，线程挂起；反之，生产者生产产品并且发出通知。\n若数据域没有内容，则消费者不消费，线程挂起；反之，消费者消费产品并且发出通知。\n P.java public class P { String lock; public P(String lock){ this.lock = lock; } public void setValue(){ try{ synchronized(lock){ //使用 if 是不严谨的做法  if (!ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait();//lock will be release, but thread exist always(waiting), and the thread loss the ability to get lock.  } String str = System.currentTimeMillis() + \u0026#34;_\u0026#34; + System.nanoTime(); System.out.println(\u0026#34;Set:\u0026#34; + str); //Produce and notify  ValueObject.value = str; lock.notify(); } }catch (Exception e){ } } }   C.java public class C String lock; public C(String lock){ this.lock = lock; } public void getValue(){ try{ synchronized(lock){ //使用 if 是不严谨的做法  if (ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait(); } String str = ValueObject.value; System.out.println(\u0026#34;Get:\u0026#34; + str); //Consume and notify  ValueObject.value = \u0026#34;\u0026#34;; lock.notify(); } }catch (Exception e){ } } }   ThreadP.java public class ThreadP extends Thread{ public P p; public ThreadP(P p){ super(); this.p = p; } @Override public void run(){ while(true){ p.setValue(); } } }   ThreadC.java public class ThreadC extends Thread{ public C c; public ThreadC(C c){ super(); this.c = c; } @Override public void run(){ while(true){ c.getValue(); } } }   Run.java public class Run { public static void main(String[] args){ String lock = \u0026#34;s\u0026#34;; Thread producer = new ThreadP(new P(lock)); Thread consumer = new ThreadC(new C(lock)); consumer.start(); producer.start(); } }  多生产者多消费者    多个生产者和多个消费者共同竞争一把锁。 多个生产者若使用 notify 进行通知，则可能出现『生产者通知消费者、消费者通知生产者、生产者通知生产者、消费者通知消费者』的情况，若通知出错的情况持续累积，就会造成程序假死。\n  P.java  public class P { String lock; public P(String lock){ this.lock = lock; } public void setValue(){ try{ synchronized(lock){ while (!ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait(); } String str = System.currentTimeMillis() + \u0026#34;_\u0026#34; + System.nanoTime(); System.out.println(Thread.currentThread().getName() + \u0026#34; Set:\u0026#34; + str); //Produce and notify  ValueObject.value = str; lock.notify(); } }catch (Exception e){ } } }    C.java  public class C { String lock; public C(String lock){ this.lock = lock; } public void getValue(){ try{ synchronized(lock){ while (ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait(); } String str = ValueObject.value; System.out.println(Thread.currentThread().getName() + \u0026#34; Get:\u0026#34; + str); //Consume and notify  ValueObject.value = \u0026#34;\u0026#34;; lock.notify(); } }catch (Exception e){ } } }    ThreadP.java  public class ThreadP extends Thread{ public P p; public ThreadP(P p){ super(); this.p = p; } @Override public void run(){ while(true){ p.setValue(); } } }    ThreadC.java  public class ThreadC extends Thread{ public C c; public ThreadC(C c){ super(); this.c = c; } @Override public void run(){ while(true){ c.getValue(); } } }    run.java  public class Run { public static void main(String[] args){ String lock = \u0026#34;s\u0026#34;; Thread[] producer = new ThreadP[2]; Thread[] consumer = new ThreadC[2]; for (int i = 0; i \u0026lt; 2; i++) { producer[i] = new ThreadP(new P(lock)); producer[i].setName(\u0026#34;生产者\u0026#34; + (i+1)); consumer[i] = new ThreadC(new C(lock)); consumer[i].setName(\u0026#34;消费者\u0026#34; + (i+1)); producer[i].start(); consumer[i].start(); } } }  以上代码只随机通知一个线程，即是说不能确定通知的对象是消费者还是生产者，如下图，当生产者生产产品之后若通知的是其他生产者线程，就会出现假死。\n如何解决 notify 通知不到其他类（假死）？\n 使用 notifyAll()\n 通知(notify)的速度比直接代码执行(比如 while 语句)慢。\n因为通知涉及到线程调度，所以 notifyAll 之后，同步块结束释放锁, while会直接进行下一次的 setValue 或者 getValue.\n关于 while 和 if 的问题：    错误的使用（等待的条件发生了改变）\n多个线程先后进入 if　块的的时候，条件还是满足的，于是多个线程进入waiting　状态，并且释放锁。当其中一个线程离开等待状态，并且通知消费者来修改进入等待的条件（　value　被清空），那么其他处于等待的线程还是会被唤醒，也做出一样的动作。\n运行过程中造成了『生产者１生产之后，通知所有。生产者２被通知到则继续生产，通知所有。生产者1被通知到则继续生产，通知所有。循环往复』、『消费者１消费了产品，通知所有。消费者２被通知到则继续消费，通知所有。消费者１被通知到则继续消费，通知所有。循环往复』的问题的偶然出现。\nsynchronized(lock){ //使用 if，处于 waiting 状态的线程被通知，若 ValueObject.value 为空，则在条件不满足的情况下也会执行业务代码（if外面的部分）  if (!ValueObject.value.equals(\u0026#34;\u0026#34;)){ System.out.println(Thread.currentThread().getName() +\u0026#34; waiting\u0026#34;); lock.wait(); } String str = System.currentTimeMillis() + \u0026#34;_\u0026#34; + System.nanoTime(); System.out.println(Thread.currentThread().getName() +\u0026#34; running\u0026#34; + \u0026#34; Set:\u0026#34; + str + \u0026#34; : \u0026#34;+ ValueObject.num++); //Produce and notify  ValueObject.value = str; lock.notify(); } 正确的使用：\nwaiting　状态的线程被通知之后，要再次判断是否应该继续等待（对等待条件再次判断）。\nsynchronized(lock){ //此处使用的是 while。处于 waiting 状态的线程被通知时，若ValueObject.value 为空，则线程应该继续等待。  while (!ValueObject.value.equals(\u0026#34;\u0026#34;)){ System.out.println(Thread.currentThread().getName() +\u0026#34; waiting\u0026#34;); lock.wait(); } String str = System.currentTimeMillis() + \u0026#34;_\u0026#34; + System.nanoTime(); System.out.println(Thread.currentThread().getName() +\u0026#34; running\u0026#34; + \u0026#34; Set:\u0026#34; + str + \u0026#34; : \u0026#34;+ ValueObject.num++); //Produce and notify  ValueObject.value = str; lock.notify(); } 这样的多个生产者对多个消费者的模式类似于点对点通信。\n对于同一块数据域，自己操作了数据域就得通知其他的所有的端，在收到通知的时候需要再次确认数据域是否可操作，不可操作则再次进入等待。\n生产者消费者模式的总结     首先需要确保使用同一把锁。 一个生产者一个消费者的情况下，使用 if 与 notify 不会影响线程的执行逻辑。 『一个生产者多个消费者、多个生产者一个消费者、多个生产者多个消费者』的情况下，必须使用 while 和 notifyAll 来保证程序运行准确。 lock.wait()使得当前线程进入 waiting 状态，并且释放锁。  "},{"id":6,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.1%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/","title":"3.1等待与通知机制","parent":"3.线程间通信","content":"while 轮询存在缺陷      A 线程执行每一步的时间较长。\npublic class ThreadA extends Thread{ private MyList list; public ThreadA(MyList list){ super(); this.list = list; } @Override public void run(){ super.run(); try{ for (int i = 0; i \u0026lt; 10; i++) { list.add(); System.out.println(Thread.currentThread().getName() + \u0026#34; Add \u0026#34; + i); Thread.sleep(1000); } }catch (InterruptedException e){ e.printStackTrace(); } } }   B线程执行轮询的时间较短\npublic class ThreadB extends Thread{ private MyList list; public ThreadB(MyList list){ super(); this.list = list; } @Override public void run(){ super.run(); try{ while (true){ if(list.size() \u0026gt;= 5){ System.out.println(\u0026#34;B Up to five.\u0026#34;); throw new InterruptedException(); } Thread.sleep(20); } }catch (InterruptedException e){ e.printStackTrace(); } } }   线程 A 和 执行循环每轮会休息 1s，线程 B 每隔 20ms 对 size 进行访问。而线程 B 的轮询，若时间太长则无法准确捕捉 list.size的变化；若时间太短则耗费大量的 CPU 资源。\n所以，使用 while 来轮询变量或者对象属性，会造成 CPU 资源的浪费；轮询间隔越短，越耗费资源。\n我们使用一种称为 wait/notify 的机制来解决这个问题。\n多线程共享变量，会有同步的问题，线程无法确保读取到的变量值是不是最新版本，而 wait/notify机制 恰好可以解决同步这个问题。\nwait/notify 机制    Java 的对象都有 wait() 方法和 notify() 方法，但需要同步加锁才能使用这个 wait/notify 机制。\n  两个线程共用一个对象监视器 lock 『共用一把锁』\n一个线程中，调用对象监视器的 wait()，该线程释放锁，并且进入等待状态。\n另外一个线程，在需要的时候调用对象监视器的 notify() 方法，会释放锁，并且随机唤醒等待同一共享资源的一个线程，但 notify 是等到同步块执行完成才释放锁。\n  ThreadA.java\npublic class ThreadA extends Thread{ private Object lock; public ThreadA(Object lock){ super(); this.lock = lock; } @Override public void run(){ super.run(); synchronized (lock){ System.out.println(\u0026#34;start.\u0026#34;); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;end\u0026#34;); } } }   ThreadB.java\npublic class ThreadB extends Thread{ private Object lock; public ThreadB(Object lock){ super(); this.lock = lock; } @Override public void run(){ super.run(); synchronized (lock){ for (int i = 0; i \u0026lt; 7; i++) { System.out.println(i); try { Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } if (i == 4){ lock.notify(); } } } } }   Run.java\npublic class Run { public static void main(String[] args) { Object lock = new Object(); ThreadA A = new ThreadA(lock); A.setName(\u0026#34;A\u0026#34;); A.start(); ThreadB B = new ThreadB(lock); B.setName(\u0026#34;B\u0026#34;); B.start(); } } 可以看到，在 i = 4 时调用notify( )，并不会马上释放锁。\n    线程状态\n  NEW 新建\n  RUNNABLE 就绪状态\n线程可以 CPU 调度，若该线程抢占到了 CPU 资源，那么就可以进入 RUNNING 状态。\n进入 Running 状态的情况\n Sleep() 休眠已结束。 线程调用的阻塞 IO 已返回，阻塞方法执行完毕。 线程成功获得了锁之后。 正在等待通知的线程，被其他线程通知，并且有最高的优先级来执行。 处于挂起状态的线程调用了 resume 方法。    BLOCKED 阻塞\n比如遇到 IO 操作，当前线程进入阻塞状态，把 CPU 时间片让给其他线程。Blocked 状态结束后，线程进入Runnable 状态。\n进入 Blocked 状态的情况\n 线程调用 Sleep() ，主动放弃占用 CPU 资源。 线程调用了 阻塞式 IO，在该方法被返回前，该线程被阻塞。 线程试图获得同步监视器，但该同步监视器正在被其他线程持有。（轮不到获得同步锁） 多个线程同时收到可触发的通知，优先级高的先获得锁得以进入runable 状态，其他线程处于 blocked 状态。 某个线程调用了 其他线程的 suspend 方法将其他线程挂起，被挂起者进入 Blocked 状态。该方法容易产生死锁。    WAITING 等待\n该线程由其他线程的 notify 来唤醒。\n  TIMED_WAITING 有限时间的等待。\n到达一定时间后自我唤醒或者受到他人唤醒。\n  TERMINATED 终止\nrun() 方法执行完毕 或者 main 方法完成之后，线程进入terminated 状态。\n    锁对象\n每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。\n  wait/notify 内容补充\n  wait() 会释放锁\n  notify() 不释放锁\n  sleep() 不释放锁\n  wait() 之后的线程，可以被 interrupt() 打断，并且释放锁。\n  通知过早\n若通知过早，会打乱程序运行逻辑。\npublic class MyRun { private String lock = new String(\u0026#34;\u0026#34;); public Runnable runnableA = new Runnable() { @Override public void run() { try{ synchronized (lock){ System.out.println(\u0026#34;Start wait\u0026#34;); lock.wait(); System.out.println(\u0026#34;End wait\u0026#34;); } }catch (Exception e){ } } }; public Runnable runnableB = new Runnable() { @Override public void run() { synchronized (lock){ System.out.println(\u0026#34;Start notify\u0026#34;); lock.notify(); System.out.println(\u0026#34;End notify\u0026#34;); } } }; } 过早通知如下\npublic static void main(String[] args) { MyRun run = new MyRun(); Thread B = new Thread(run.runnableB); B.setName(\u0026#34;B\u0026#34;); Thread A = new Thread(run.runnableA); A.setName(\u0026#34;A\u0026#34;); B.start(); //先通知  A.start(); //再等待 } 正常顺序启动\npublic static void main(String[] args) { MyRun run = new MyRun(); Thread B = new Thread(run.runnableB); B.setName(\u0026#34;B\u0026#34;); Thread A = new Thread(run.runnableA); A.setName(\u0026#34;A\u0026#34;); A.start(); //先等待  B.start(); //再通知 }   wait 的条件发生变化会导致程序逻辑的混乱\n  小结     wait() 与 Thread.sleep()的区别 wait() 会释放同步锁，而Thread.sleep() 不会释放锁。    "},{"id":7,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","title":"3.线程间通信","parent":"简介","content":" wait/notify 生产者/消费者模式 管道流 PipedOutputStream, PipedInputStream join ThreadLocal  "},{"id":8,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.3%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95/","title":"2.3其它方法","parent":"2.对象及变量的并发访问","content":"1. volatile 关键字    为了实现变量在多个线程间可见。使得线程从公共堆栈中获取变量，而不是线程私有数据栈。\nJVM 在 -sever 模式时为了线程运行效率，线程一直在私有堆栈中获取变量值，而主线程的变量是存储在公共堆栈中，解决这种可见性问题，可以使用 volatile 。\nvolatile 与 synchronized 的比较：\n  volatile 保证可见性但不保证原子性（致命缺点），synchronized 保证原子性但不保证可见性。\n  volatile 只能修饰变量。\n  volatile 不发生阻塞，synchronized 会阻塞。\n  2. 原子类    多线程使用原子操作访问共享资源时，不需要锁也可保证线程安全（多线程访问同一资源时，不会出现脏读或写失败）。\n以下代码，多个线程竞争地访问同一个对象中的 count ， 使用原子操作保证了线程安全。\n  CountService.java\npublic class CountService extends Thread{ private AtomicInteger count = new AtomicInteger(0);//原子类  @Override public void run(){ for (int i = 0; i \u0026lt; 1000; i++){ System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; +count.incrementAndGet());//incrementAndGet 方法是原子操作  } } }   Run.java\npublic class Run { public static void main(String[] args) { CountService countService = new CountService(); Thread t1 = new Thread(countService); t1.setName(\u0026#34;t1\u0026#34;); t1.start(); Thread t2 = new Thread(countService); t2.setName(\u0026#34;t2\u0026#34;); t2.start(); Thread t3 = new Thread(countService); t3.setName(\u0026#34;t3\u0026#34;); t3.start(); } }   方法间的调用不是原子的（调用多个原子操作，不具有原子性，线程间会出现抢占），需要使用 synchronized 来保证线程安全。\n"},{"id":9,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.2%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85/","title":"2.2同步中的无限等待","parent":"2.对象及变量的并发访问","content":"1.静态同步与 synchronized(class)    静态同步锁定的是类。\n  多个对象共用一把锁\n同一个类如果使用常量字符（常量字符串是存放在缓存中）串作为 synchronized(string) 对象监视器，并且对象 A 的同步方法中有死循环，那么其他对象无法调用该同步方法，表现为无限等待（其他线程被锁住）。\n  一个对象一把锁\n使用局部变量的方式可以避免锁住其他线程。\n  2. synchronized 无限等待    因为 synchronized 锁定的是对象，同一个对象的方法同步执行，当一个线程执行某个方法存在死循环时，其他线程会陷入无限等待。如下，thread 与 threadB 共用一个 service 。\npublic class Service { synchronized public void service1(){ System.out.println(\u0026#34;service1\u0026#34;); while (true){ System.out.println(\u0026#34;ha\u0026#34;); } } synchronized public void service2(){ System.out.println(\u0026#34;service2\u0026#34;); } } public class MyThread extends Thread{ Service service; public MyThread(Service service){ this.service = service; } @Override public void run(){ super.run(); service.service1(); } } public class MyThreadB extends Thread{ Service service; public MyThreadB(Service service){ this.service = service; } @Override public void run(){ super.run(); service.service2(); } } public class Run { public static void main(String[] args) { Service service = new Service();//two threads use the same service.  MyThread myThread = new MyThread(service); myThread.start(); MyThreadB myThreadB = new MyThreadB(service); myThreadB.start(); } } 解决方法：同步块并且对象监视器使用不同对象。一个方法对应一个对象监视器，做到单个方法的同步（锁住单个方法）。\npublic class Service { Object object = new Object(); public void service1(){ synchronized(object){ System.out.println(\u0026#34;service1\u0026#34;); while (true){ System.out.println(\u0026#34;ha\u0026#34;); } } } Object object1 = new Object(); public void service2(){ synchronized (object1){ System.out.println(\u0026#34;service2\u0026#34;); } } } 3. 多线程死锁    死锁条件：\n 互斥(一份资源同时只能供一个线程使用) 占有且等待 不可抢占 循环等待  以下举例了 4 秒钟的死锁，线程占有的时间越长，死锁时间越长。\npublic class DealThread implements Runnable{ public String username; public Object lock1 = new Object(); public Object lock2 = new Object(); public void setFlag(String username){ this.username = username; } @Override public void run(){ if (username.equals(\u0026#34;a\u0026#34;)){ synchronized (lock1){ System.out.println(\u0026#34;username: \u0026#34; + username); try{ Thread.sleep(4000);//4 second dead lock  }catch(Exception e){ e.printStackTrace(); } } synchronized (lock2){ System.out.println(\u0026#34;lock2 username: \u0026#34; + username); } }else if(username.equals(\u0026#34;b\u0026#34;)){ synchronized (lock2){ System.out.println(\u0026#34;username: \u0026#34; + username); try{ Thread.sleep(4000);//4 second dead lock  }catch(Exception e){ e.printStackTrace(); } } synchronized (lock1){ System.out.println(\u0026#34;lock1 username: \u0026#34; + username); } } } } "},{"id":10,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.1%E5%90%8C%E6%AD%A5/","title":"2.1同步","parent":"2.对象及变量的并发访问","content":"1. 单例模式下并发访问同一个对象的内容    synchnized 同步锁，使得调用方法变成同步访问对象属性。\n2.多个对象多把锁    方法带有 synchronized 则一个对象带有一把锁，多个对象在 JVM 中是异步的，所以多个对象的多把锁表现为异步的。\n3. 脏读    setValue() 时，中途进行 getValue() ，如果 getValue() 没有同步则可能出现脏读。\n同步锁作用于对象，非同步方法可以异步调用，同一对象的多个同步方法是同步调用。\npublic class MyObject { private String userName = \u0026#34;A\u0026#34;; private String password = \u0026#34;AA\u0026#34;; synchronized public void setValue(String userName, String password){ this.userName = userName; try { Thread.sleep(3000);//delay cause the dirtyRead  }catch (Exception e){ } this.password = password; } public void getValue(){ System.out.println(this.userName + \u0026#34;,\u0026#34; + this.password); } } getValue() 加上同步之后不会有脏读\npublic class MyObject { private String userName = \u0026#34;A\u0026#34;; private String password = \u0026#34;AA\u0026#34;; synchronized public void setValue(String userName, String password){ this.userName = userName; try { Thread.sleep(3000);//delay cause the dirtyRead  }catch (Exception e){ } this.password = password; } //Add synchronized  synchronized public void getValue(){ System.out.println(this.userName + \u0026#34;,\u0026#34; + this.password); } } 4. synchronized 锁的重入    一个线程获得某个对象的锁，对象锁未释放时还想再次获得锁，是可以的。\n如果锁不可重入，会造成死锁。\n子类可以通过“可重入锁”调用父类的同步方法。\n当前线程出现异常时，锁自动释放。\n同步不具有继承性。\n5. synchronized 的弊端    若 A 线程执行任务花的时间较长，那么 B 线程会等待较长时间。\n  可以使用同步块的方法来解决，同步块也是锁定对象。\nsynchronized(this){ this.data = data; } 只同步共用的部分。\n  小结     每个对象都具有锁性质。 synchronized 默认锁住的是对象 synchronized(object) 是使用对象监视器来实现同步，使用的锁是 object 的锁。 锁是一个线程与一个同步监视器（锁对象）之间的关系，对象自己作为锁时『synchronized(this)』，自己线程对锁（自身）的访问也涉及锁。不同线程间不加 synchronized 则认为是异步调用。  "},{"id":11,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/","title":"2.对象及变量的并发访问","parent":"简介","content":"同步 synchronized，异步 asynchronized。\n资源共享才需要同步。\n被锁住的变量称为互斥区或临界区。\n持有相同的锁对象监视器则同步，分别持有锁对象监视器则异步。\n"},{"id":12,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/1.2%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"1.2线程控制","parent":"1.多线程的使用","content":"停止线程      this.interrupted() 测试当前线程是否已经是中断状态，执行后把标志位设置为 false 。\n  this.isInterrupted() 测试线程 Thread 是否已经中断，但不清除标志位。\n  thread.interrupt()，run 方法中有sleep，使用try的 catch可以捕捉到 InterruptedException。\n  异常法停止一个线程，抛出 InterruptedException 。（推荐）\n  thread.stop() 暴力停止，不推荐。\n  使用 return 停止线程。\n  暂停线程     suspend 与resume 它们的缺陷：独占（不同步）。如果子线程中有调用 synchronized 方法，将导致同步锁可能未被释放，在主线程调用相同 synchronized 方法时无法获得锁，程序卡住。  yield 方法    交出控制权\nthread.yield()\n放弃当前 CPU 资源，让给其他任务去占用。（但放弃的时间不确定，可能很短）\n牺牲自我，成就他人。\n线程优先级    A 调用 B ，则默认的， B 的优先级与 A 一致。\n 规则性，按优先级的高低来分配 CPU 资源，优先级 1-10 逐次增高。 随机性，优先级高的不一定先执行完，优先级高只是保证会被尽量多地分配运行资源。  thread.setPriority(6);//设置优先级 守护线程    线程分为：用户线程、守护线程。\nGC 即是守护线程的一种。\n当前 JVM 实例中，最后一个 非守护线程（用户线程） 结束了，守护线程才结束。\nthread.setDeamon(true);//将 thread 设定为守护线程。 "},{"id":13,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"1.多线程的使用","parent":"简介","content":""},{"id":14,"href":"/blog/","title":"Blog","parent":"简介","content":""},{"id":15,"href":"/blog/life/","title":"Life","parent":"Blog","content":"关于 Hugo GeekDoc     GitHub 先新建一个仓库，并配置 Github Pages。 下载 geekdoc 的 release，放到 theme 文件夹下。 配置config.toml baseURL = \u0026#39;http://example.org/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;技术学习笔记\u0026#39; theme = \u0026#34;hugo-geekdoc\u0026#34; # Match the github rule. publishdir = \u0026#34;./docs/\u0026#34; pluralizeListTitles = false # Geekdoc required configuration pygmentsUseClasses = true pygmentsCodeFences = true disablePathToLower = true # Needed for mermaid shortcodes [markup] [markup.goldmark.renderer] # Needed for mermaid shortcode unsafe = true [markup.tableOfContents] startLevel = 1 endLevel = 9 [taxonomies] tag = \u0026#34;tags\u0026#34;  开始写文章 hugo new blog/life.md  测试 hugo server -D  生成 HTML hugo -D   Hugo 使用方法      提示板 提示板\n这是 hint ok\n 提示板\n这是 hint info\n 提示板\n这是 hint warn\n 提示板\n这是 hint danger\n 提示板\n这是 hint\n   导航栏\n 目录只允许在 content 下多加一层。    在学校    研一9月      到校占工位啦\n把思昊君赠予的显示器摆上了我的工位，桌板上有个洞和显示器支架的脚刚好契合，可以把显示器竖起来，竖屏即刻体验拉满。   舍友的 C++ 海报\nC++ 的框架尽显眼前   "},{"id":16,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/1.1%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B/","title":"1.1线程新建","parent":"1.多线程的使用","content":"以 Thread 实例的方式    Mythread.java\npackage threadTest; public class MyThread extends Thread{ @Override public void run(){ super.run(); for (int i = 0; i \u0026lt; 100; i++){ System.out.println(\u0026#34;MyThread:\u0026#34; + i); } } } Main.java\npackage threadTest; public class main { public static void main(String[] args){ MyThread myThread = new MyThread(); myThread.start(); MyThread myThread1 = new MyThread(); myThread1.start(); System.out.println(\u0026#34;Has been ran\u0026#34;); } } 以包装 Runnable 的方式    因为 Runnable 接口中只有 run 方法，无法启动一个新的线程。所以借由 Thread 的构造，可以新建线程。\nRunnable.java\npackage threadTest; public class MyRunnable implements Runnable{ @Override public void run(){ System.out.println(\u0026#34;Runnable\u0026#34;); } } Run.java\npackage threadTest; public class Run { public static void main(String[] args) { Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); //runnable has no \u0026#39;start\u0026#39; method, so use thread to decorate(compact).  thread.start(); System.out.println(\u0026#34;done\u0026#34;); } } start() 与 run() 的区别      调用 start() 是通知线程规划器，目标线程已经准备好了，线程规划器可以安排一个时间来启动目标线程，属于异步执行。\n  调用 run() 时，是直接执行对应的目标线程的代码段，执行完 run() 中的代码才会继续下一步，属于同步执行。\n  "},{"id":17,"href":"/","title":"简介","parent":"","content":"关于 Blog：学习心得的记录、学习笔记。    "},{"id":18,"href":"/tags/","title":"Tags","parent":"简介","content":""}]