[{"id":0,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.2%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"3.2生产者消费者模式","parent":"3.线程间通信","content":"问题：\n threadP 在 setValue 时，lock.wait 失去了锁, 线程还会继续存在吗？ 『解答』还会继续存在, 但是处于 waiting 状态。没有能力去获取同步锁。\n  锁是可以重入的，是否意味着在 while 循环的作用下，会多次调用 setValue，而有一部分的调用被阻塞了得不到响应？ 『解答』不会多次调用 setValue。\n  锁可以重入，在上一个 lock.wait 未响应的情况下，是否可以再进入同步块进行对应操作？ 『解答』执行了 lock.wait 线程就被挂起，进入 waiting 状态。\n  一个生产者、一个消费者 基于 wait/notify 机制 P.java\npublic class P { String lock; public P(String lock){ this.lock = lock; } public void setValue(){ try{ synchronized(lock){ if (!ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait();//lock will be release, but thread exist always.  } String str = System.currentTimeMillis() + \u0026#34;_\u0026#34; + System.nanoTime(); System.out.println(\u0026#34;Set:\u0026#34; + str); //Produce and notify  ValueObject.value = str; lock.notify(); } }catch (Exception e){ } } } C.java\npublic class C String lock; public C(String lock){ this.lock = lock; } public void getValue(){ try{ synchronized(lock){ if (ValueObject.value.equals(\u0026#34;\u0026#34;)){ lock.wait(); } String str = ValueObject.value; System.out.println(\u0026#34;Get:\u0026#34; + str); //Consume and notify  ValueObject.value = \u0026#34;\u0026#34;; lock.notify(); } }catch (Exception e){ } } } ThreadP.java\npublic class ThreadP extends Thread{ public P p; public ThreadP(P p){ super(); this.p = p; } @Override public void run(){ while(true){ p.setValue(); } } } ThreadC.java\npublic class ThreadC extends Thread{ public C c; public ThreadC(C c){ super(); this.c = c; } @Override public void run(){ while(true){ c.getValue(); } } } Run.java\npublic class Run { public static void main(String[] args){ String lock = \u0026#34;s\u0026#34;; Thread producer = new ThreadP(new P(lock)); Thread consumer = new ThreadC(new C(lock)); consumer.start(); producer.start(); } }  "},{"id":1,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/3.1%E7%AD%89%E5%BE%85%E4%B8%8E%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/","title":"3.1等待与通知机制","parent":"3.线程间通信","content":"while 轮询存在缺陷      A 线程执行每一步的时间较长。\npublic class ThreadA extends Thread{ private MyList list; public ThreadA(MyList list){ super(); this.list = list; } @Override public void run(){ super.run(); try{ for (int i = 0; i \u0026lt; 10; i++) { list.add(); System.out.println(Thread.currentThread().getName() + \u0026#34; Add \u0026#34; + i); Thread.sleep(1000); } }catch (InterruptedException e){ e.printStackTrace(); } } }   B线程执行轮询的时间较短\npublic class ThreadB extends Thread{ private MyList list; public ThreadB(MyList list){ super(); this.list = list; } @Override public void run(){ super.run(); try{ while (true){ if(list.size() \u0026gt;= 5){ System.out.println(\u0026#34;B Up to five.\u0026#34;); throw new InterruptedException(); } Thread.sleep(20); } }catch (InterruptedException e){ e.printStackTrace(); } } }   线程 A 和 执行循环每轮会休息 1s，线程 B 每隔 20ms 对 size 进行访问。而线程 B 的轮询，若时间太长则无法准确捕捉 list.size的变化；若时间太短则耗费大量的 CPU 资源。\n所以，使用 while 来轮询变量或者对象属性，会造成 CPU 资源的浪费；轮询间隔越短，越耗费资源。\n我们使用一种称为 wait/notify 的机制来解决这个问题。\n多线程共享变量，会有同步的问题，线程无法确保读取到的变量值是不是最新版本，而 wait/notify机制 恰好可以解决同步这个问题。\nwait/notify 机制    Java 的对象都有 wait() 方法和 notify() 方法，但需要同步加锁才能使用这个 wait/notify 机制。\n  两个线程共用一个对象监视器 lock 『共用一把锁』\n一个线程中，调用对象监视器的 wait()，该线程释放锁，并且进入等待状态。\n另外一个线程，在需要的时候调用对象监视器的 notify() 方法，会释放锁，并且随机唤醒等待同一共享资源的一个线程，但 notify 是等到同步块执行完成才释放锁。\n  ThreadA.java\npublic class ThreadA extends Thread{ private Object lock; public ThreadA(Object lock){ super(); this.lock = lock; } @Override public void run(){ super.run(); synchronized (lock){ System.out.println(\u0026#34;start.\u0026#34;); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;end\u0026#34;); } } }   ThreadB.java\npublic class ThreadB extends Thread{ private Object lock; public ThreadB(Object lock){ super(); this.lock = lock; } @Override public void run(){ super.run(); synchronized (lock){ for (int i = 0; i \u0026lt; 7; i++) { System.out.println(i); try { Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } if (i == 4){ lock.notify(); } } } } }   Run.java\npublic class Run { public static void main(String[] args) { Object lock = new Object(); ThreadA A = new ThreadA(lock); A.setName(\u0026#34;A\u0026#34;); A.start(); ThreadB B = new ThreadB(lock); B.setName(\u0026#34;B\u0026#34;); B.start(); } } 可以看到，在 i = 4 时调用notify( )，并不会马上释放锁。\n    线程状态\n  NEW 新建\n  RUNNABLE 就绪状态\n线程可以 CPU 调度，若该线程抢占到了 CPU 资源，那么就可以进入 RUNNING 状态。\n进入 Running 状态的情况\n Sleep() 休眠已结束。 线程调用的阻塞 IO 已返回，阻塞方法执行完毕。 线程成功获得了锁之后。 正在等待通知的线程，被其他线程通知，并且有最高的优先级来执行。 处于挂起状态的线程调用了 resume 方法。    BLOCKED 阻塞\n比如遇到 IO 操作，当前线程进入阻塞状态，把 CPU 时间片让给其他线程。Blocked 状态结束后，线程进入Runnable 状态。\n进入 Blocked 状态的情况\n 线程调用 Sleep() ，主动放弃占用 CPU 资源。 线程调用了 阻塞式 IO，在该方法被返回前，该线程被阻塞。 线程试图获得同步监视器，但该同步监视器正在被其他线程持有。（轮不到获得同步锁） 多个线程同时收到可触发的通知，优先级高的先获得锁得以进入runable 状态，其他线程处于 blocked 状态。 某个线程调用了 其他线程的 suspend 方法将其他线程挂起，被挂起者进入 Blocked 状态。该方法容易产生死锁。    WAITING 等待\n该线程由其他线程的 notify 来唤醒。\n  TIMED_WAITING 有限时间的等待。\n到达一定时间后自我唤醒或者受到他人唤醒。\n  TERMINATED 终止\nrun() 方法执行完毕 或者 main 方法完成之后，线程进入terminated 状态。\n    锁对象\n每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。\n  wait/notify 内容补充\n  wait() 会释放锁\n  notify() 不释放锁\n  sleep() 不释放锁\n  wait() 之后的线程，可以被 interrupt() 打断，并且释放锁。\n  通知过早\n若通知过早，会打乱程序运行逻辑。\npublic class MyRun { private String lock = new String(\u0026#34;\u0026#34;); public Runnable runnableA = new Runnable() { @Override public void run() { try{ synchronized (lock){ System.out.println(\u0026#34;Start wait\u0026#34;); lock.wait(); System.out.println(\u0026#34;End wait\u0026#34;); } }catch (Exception e){ } } }; public Runnable runnableB = new Runnable() { @Override public void run() { synchronized (lock){ System.out.println(\u0026#34;Start notify\u0026#34;); lock.notify(); System.out.println(\u0026#34;End notify\u0026#34;); } } }; } 过早通知如下\npublic static void main(String[] args) { MyRun run = new MyRun(); Thread B = new Thread(run.runnableB); B.setName(\u0026#34;B\u0026#34;); Thread A = new Thread(run.runnableA); A.setName(\u0026#34;A\u0026#34;); B.start(); //先通知  A.start(); //再等待 } 正常顺序启动\npublic static void main(String[] args) { MyRun run = new MyRun(); Thread B = new Thread(run.runnableB); B.setName(\u0026#34;B\u0026#34;); Thread A = new Thread(run.runnableA); A.setName(\u0026#34;A\u0026#34;); A.start(); //先等待  B.start(); //再等待 }   wait 的条件发生变化会导致程序逻辑的混乱\n    "},{"id":2,"href":"/3.%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","title":"3.线程间通信","parent":"简介","content":" wait/notify 生产者/消费者模式 join ThreadLocal  "},{"id":3,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.3%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95/","title":"2.3其它方法","parent":"2.对象及变量的并发访问","content":"1. volatile 关键字    为了实现变量在多个线程间可见。使得线程从公共堆栈中获取变量，而不是线程私有数据栈。\nJVM 在 -sever 模式时为了线程运行效率，线程一直在私有堆栈中获取变量值，而主线程的变量是存储在公共堆栈中，解决这种可见性问题，可以使用 volatile 。\nvolatile 与 synchronized 的比较：\n  volatile 保证可见性但不保证原子性（致命缺点），synchronized 保证原子性但不保证可见性。\n  volatile 只能修饰变量。\n  volatile 不发生阻塞，synchronized 会阻塞。\n  2. 原子类    多线程使用原子操作访问共享资源时，不需要锁也可保证线程安全（多线程访问同一资源时，不会出现脏读或写失败）。\n以下代码，多个线程竞争地访问同一个对象中的 count ， 使用原子操作保证了线程安全。\n  CountService.java\npublic class CountService extends Thread{ private AtomicInteger count = new AtomicInteger(0);//原子类  @Override public void run(){ for (int i = 0; i \u0026lt; 1000; i++){ System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; +count.incrementAndGet());//incrementAndGet 方法是原子操作  } } }   Run.java\npublic class Run { public static void main(String[] args) { CountService countService = new CountService(); Thread t1 = new Thread(countService); t1.setName(\u0026#34;t1\u0026#34;); t1.start(); Thread t2 = new Thread(countService); t2.setName(\u0026#34;t2\u0026#34;); t2.start(); Thread t3 = new Thread(countService); t3.setName(\u0026#34;t3\u0026#34;); t3.start(); } }   方法间的调用不是原子的（调用多个原子操作，不具有原子性，线程间会出现抢占），需要使用 synchronized 来保证线程安全。\n"},{"id":4,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.2%E5%90%8C%E6%AD%A5%E4%B8%AD%E7%9A%84%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85/","title":"2.2同步中的无限等待","parent":"2.对象及变量的并发访问","content":"1.静态同步与 synchronized(class)    静态同步锁定的是类。\n  多个对象共用一把锁\n同一个类如果使用常量字符（常量字符串是存放在缓存中）串作为 synchronized(string) 对象监视器，并且对象 A 的同步方法中有死循环，那么其他对象无法调用该同步方法，表现为无限等待（其他线程被锁住）。\n  一个对象一把锁\n使用局部变量的方式可以避免锁住其他线程。\n  2. synchronized 无限等待    因为 synchronized 锁定的是对象，同一个对象的方法同步执行，当一个线程执行某个方法存在死循环时，其他线程会陷入无限等待。如下，thread 与 threadB 共用一个 service 。\npublic class Service { synchronized public void service1(){ System.out.println(\u0026#34;service1\u0026#34;); while (true){ System.out.println(\u0026#34;ha\u0026#34;); } } synchronized public void service2(){ System.out.println(\u0026#34;service2\u0026#34;); } } public class MyThread extends Thread{ Service service; public MyThread(Service service){ this.service = service; } @Override public void run(){ super.run(); service.service1(); } } public class MyThreadB extends Thread{ Service service; public MyThreadB(Service service){ this.service = service; } @Override public void run(){ super.run(); service.service2(); } } public class Run { public static void main(String[] args) { Service service = new Service();//two threads use the same service.  MyThread myThread = new MyThread(service); myThread.start(); MyThreadB myThreadB = new MyThreadB(service); myThreadB.start(); } } 解决方法：同步块并且对象监视器使用不同对象。一个方法对应一个对象监视器，做到单个方法的同步（锁住单个方法）。\npublic class Service { Object object = new Object(); public void service1(){ synchronized(object){ System.out.println(\u0026#34;service1\u0026#34;); while (true){ System.out.println(\u0026#34;ha\u0026#34;); } } } Object object1 = new Object(); public void service2(){ synchronized (object1){ System.out.println(\u0026#34;service2\u0026#34;); } } } 3. 多线程死锁    死锁条件：\n 互斥(一份资源同时只能供一个线程使用) 占有且等待 不可抢占 循环等待  以下举例了 4 秒钟的死锁，线程占有的时间越长，死锁时间越长。\npublic class DealThread implements Runnable{ public String username; public Object lock1 = new Object(); public Object lock2 = new Object(); public void setFlag(String username){ this.username = username; } @Override public void run(){ if (username.equals(\u0026#34;a\u0026#34;)){ synchronized (lock1){ System.out.println(\u0026#34;username: \u0026#34; + username); try{ Thread.sleep(4000);//4 second dead lock  }catch(Exception e){ e.printStackTrace(); } } synchronized (lock2){ System.out.println(\u0026#34;lock2 username: \u0026#34; + username); } }else if(username.equals(\u0026#34;b\u0026#34;)){ synchronized (lock2){ System.out.println(\u0026#34;username: \u0026#34; + username); try{ Thread.sleep(4000);//4 second dead lock  }catch(Exception e){ e.printStackTrace(); } } synchronized (lock1){ System.out.println(\u0026#34;lock1 username: \u0026#34; + username); } } } } "},{"id":5,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/2.1%E5%90%8C%E6%AD%A5/","title":"2.1同步","parent":"2.对象及变量的并发访问","content":"1. 单例模式下并发访问同一个对象的内容    synchnized 同步锁，使得调用方法变成同步访问对象属性。\n2.多个对象多把锁    方法带有 synchronized 则一个对象带有一把锁，多个对象在 JVM 中是异步的，所以多个对象的多把锁表现为异步的。\n3. 脏读    setValue() 时，中途进行 getValue() ，如果 getValue() 没有同步则可能出现脏读。\n同步锁作用于对象，非同步方法可以异步调用，同一对象的多个同步方法是同步调用。\npublic class MyObject { private String userName = \u0026#34;A\u0026#34;; private String password = \u0026#34;AA\u0026#34;; synchronized public void setValue(String userName, String password){ this.userName = userName; try { Thread.sleep(3000);//delay cause the dirtyRead  }catch (Exception e){ } this.password = password; } public void getValue(){ System.out.println(this.userName + \u0026#34;,\u0026#34; + this.password); } } getValue() 加上同步之后不会有脏读\npublic class MyObject { private String userName = \u0026#34;A\u0026#34;; private String password = \u0026#34;AA\u0026#34;; synchronized public void setValue(String userName, String password){ this.userName = userName; try { Thread.sleep(3000);//delay cause the dirtyRead  }catch (Exception e){ } this.password = password; } //Add synchronized  synchronized public void getValue(){ System.out.println(this.userName + \u0026#34;,\u0026#34; + this.password); } } 4. synchronized 锁的重入    一个线程获得某个对象的锁，对象锁未释放时还想再次获得锁，是可以的。\n如果锁不可重入，会造成死锁。\n子类可以通过“可重入锁”调用父类的同步方法。\n当前线程出现异常时，锁自动释放。\n同步不具有继承性。\n5. synchronized 的弊端    若 A 线程执行任务花的时间较长，那么 B 线程会等待较长时间。\n  可以使用同步块的方法来解决，同步块也是锁定对象。\nsynchronized(this){ this.data = data; } 只同步共用的部分。\n  "},{"id":6,"href":"/2.%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE/","title":"2.对象及变量的并发访问","parent":"简介","content":"同步 synchronized，异步 asynchronized。\n资源共享才需要同步。\n被锁住的变量称为互斥区或临界区。\n持有相同的锁对象监视器则同步，分别持有锁对象监视器则异步。\n"},{"id":7,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/1.2%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"1.2线程控制","parent":"1.多线程的使用","content":"停止线程      this.interrupted() 测试当前线程是否已经是中断状态，执行后把标志位设置为 false 。\n  this.isInterrupted() 测试线程 Thread 是否已经中断，但不清除标志位。\n  thread.interrupt()，run 方法中有sleep，使用try的 catch**可以捕捉到 InterruptedException **的。\n  异常法停止一个线程，抛出 InterruptedException 。（推荐）\n  thread.stop() 暴力停止，不推荐。\n  使用 return 停止线程。\n  暂停线程     suspend 与resume 它们的缺陷：独占（不同步）。如果子线程中有调用 synchronized 方法，将导致同步锁可能未被释放，在主线程调用相同 synchronized 方法时无法获得锁，程序卡住。  yield 方法    交出控制权\nthread.yield()\n放弃当前 CPU 资源，让给其他任务去占用。（但放弃的时间不确定，可能很短）\n牺牲自我，成就他人。\n线程优先级    A 调用 B ，则默认的， B 的优先级与 A 一致。\n 规则性，按优先级的高低来分配 CPU 资源，优先级 1-10 逐次增高。 随机性，优先级高的不一定先执行完，优先级高只是保证会被尽量多地分配运行资源。  thread.setPriority(6);//设置优先级 守护线程    线程分为：用户线程、守护线程。\nGC 即是守护线程的一种。\n当前 JVM 实例中，最后一个 非守护线程（用户线程） 结束了，守护线程才结束。\nthread.setDeamon(true);//将 thread 设定为守护线程。 "},{"id":8,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"1.多线程的使用","parent":"简介","content":""},{"id":9,"href":"/blog/","title":"Blog","parent":"简介","content":""},{"id":10,"href":"/blog/life/","title":"Life","parent":"Blog","content":"关于 Hugo GeekDoc     GitHub 先新建一个仓库，并配置 Github Pages。 下载 geekdoc 的 release，放到 theme 文件夹下。 配置config.toml baseURL = \u0026#39;http://example.org/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;技术学习笔记\u0026#39; theme = \u0026#34;hugo-geekdoc\u0026#34; # Match the github rule. publishdir = \u0026#34;./docs/\u0026#34; pluralizeListTitles = false # Geekdoc required configuration pygmentsUseClasses = true pygmentsCodeFences = true disablePathToLower = true # Needed for mermaid shortcodes [markup] [markup.goldmark.renderer] # Needed for mermaid shortcode unsafe = true [markup.tableOfContents] startLevel = 1 endLevel = 9 [taxonomies] tag = \u0026#34;tags\u0026#34;  开始写文章 hugo new blog/life.md  测试 hugo server -D  生成 HTML hugo -D   Hugo 使用方法      提示板 提示板\n这是 hint ok\n 提示板\n这是 hint info\n 提示板\n这是 hint warn\n 提示板\n这是 hint danger\n 提示板\n这是 hint\n   导航栏\n 目录只允许在 content 下多加一层。    在学校    研一9月      到校占工位啦\n把思昊君赠予的显示器摆上了我的工位，桌板上有个洞和显示器支架的脚刚好契合，可以把显示器竖起来，竖屏即刻体验拉满。   舍友的 C++ 海报\nC++ 的框架尽显眼前   "},{"id":11,"href":"/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/1.1%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B/","title":"1.1线程新建","parent":"1.多线程的使用","content":"以 Thread 实例的方式    Mythread.java\npackage threadTest; public class MyThread extends Thread{ @Override public void run(){ super.run(); for (int i = 0; i \u0026lt; 100; i++){ System.out.println(\u0026#34;MyThread:\u0026#34; + i); } } } Main.java\npackage threadTest; public class main { public static void main(String[] args){ MyThread myThread = new MyThread(); myThread.start(); MyThread myThread1 = new MyThread(); myThread1.start(); System.out.println(\u0026#34;Has been ran\u0026#34;); } } 以包装 Runnable 的方式    因为 Runnable 接口中只有 run 方法，无法启动一个新的线程。所以借由 Thread 的构造，可以新建线程。\nRunnable.java\npackage threadTest; public class MyRunnable implements Runnable{ @Override public void run(){ System.out.println(\u0026#34;Runnable\u0026#34;); } } Run.java\npackage threadTest; public class Run { public static void main(String[] args) { Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); //runnable has no \u0026#39;start\u0026#39; method, so use thread to decorate(compact).  thread.start(); System.out.println(\u0026#34;done\u0026#34;); } } start() 与 run() 的区别      调用 start() 是通知线程规划器，目标线程已经准备好了，线程规划器可以安排一个时间来启动目标线程，属于异步执行。\n  调用 run() 时，是直接执行对应的目标线程的代码段，执行完 run() 中的代码才会继续下一步，属于同步执行。\n  "},{"id":12,"href":"/","title":"简介","parent":"","content":"关于 Blog：学习心得的记录、学习笔记。    "},{"id":13,"href":"/tags/","title":"Tags","parent":"简介","content":""}]