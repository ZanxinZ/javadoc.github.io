[{"id":0,"href":"/blog/","title":"Blog","parent":"简介","content":""},{"id":1,"href":"/blog/life/","title":"Life","parent":"Blog","content":"在学校    "},{"id":2,"href":"/1.%E7%BA%BF%E7%A8%8B%E6%96%B0%E5%BB%BA/","title":"1.线程新建","parent":"简介","content":""},{"id":3,"href":"/1.%E7%BA%BF%E7%A8%8B%E6%96%B0%E5%BB%BA/start%E4%B8%8Erun%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"Start()与run()的区别","parent":"1.线程新建","content":"  调用 start() 是通知线程规划器，目标线程已经准备好了，线程规划器可以安排一个时间来启动目标线程，属于异步执行。\n  调用 run() 时，是直接执行对应的目标线程的代码段，执行完 run() 中的代码才会继续下一步，属于同步执行。\n  "},{"id":4,"href":"/1.%E7%BA%BF%E7%A8%8B%E6%96%B0%E5%BB%BA/runnable%E6%96%B9%E5%BC%8F/","title":"Runnable方式","parent":"1.线程新建","content":"因为 Runnable 接口中只有 run 方法，无法启动一个新的线程。所以借由 Thread 的构造，从而可以新建线程。\nRunnable.java\npackage threadTest; public class MyRunnable implements Runnable{ @Override public void run(){ System.out.println(\u0026#34;Runnable\u0026#34;); } } Run.java\npackage threadTest; public class Run { public static void main(String[] args) { Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); //runnable has no \u0026#39;start\u0026#39; method, so use thread to decorate(compact).  thread.start(); System.out.println(\u0026#34;done\u0026#34;); } } "},{"id":5,"href":"/1.%E7%BA%BF%E7%A8%8B%E6%96%B0%E5%BB%BA/thread%E6%96%B9%E5%BC%8F/","title":"Thread方式","parent":"1.线程新建","content":"Mythread.java\npackage threadTest; public class MyThread extends Thread{ @Override public void run(){ super.run(); for (int i = 0; i \u0026lt; 100; i++){ System.out.println(\u0026#34;MyThread:\u0026#34; + i); } } } Main.java\npackage threadTest; public class main { public static void main(String[] args){ MyThread myThread = new MyThread(); myThread.start(); MyThread myThread1 = new MyThread(); myThread1.start(); System.out.println(\u0026#34;Has been ran\u0026#34;); } } "},{"id":6,"href":"/","title":"简介","parent":"","content":"关于 Blog：学习心得的记录、学习笔记。    "},{"id":7,"href":"/tags/","title":"Tags","parent":"简介","content":""}]